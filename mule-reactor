#!/usr/bin/env ruby
require 'listen'
require 'fileutils'
require 'find'
require 'rexml/document'
include REXML
require 'json'
require 'optparse'
require 'ostruct'
require 'filewatcher'
require 'open3'


# TODO/Ideas
# * Improve error handling
# * Would it be possible to only update files if the diff and ignoring white spaces 

# Initialize options with default values
options = OpenStruct.new(verbose: false, watch_pom: false, notification: false, watch_deployments: false,projects_dir: Dir.pwd, apps_dir: "#{ENV['MULE_HOME']}/apps")

OptionParser.new do |parser|
  parser.banner = "Usage: ruby #{File.basename(__FILE__)} [options]"

  parser.on("-h", "--help", "Display this help and exit") do
    puts parser
    exit
  end

  parser.on("-v", "--verbose", "Run script in verbose mode") do
    options.verbose = true
  end

  parser.on("-n", "--notification", "Enable notifications") do
    options.notification = true
  end

  parser.on("-d", "--watch-deployments", "Will tail the sever-log and notify on deployment status. Notification must be enable and this might not work on windows") do
    options.watch_deployments = true
  end

  parser.on("-p", "--watch-pom", "Detect changes in pom.xml and rebuild when relevant content has changed") do
    options.watch_pom = true
  end

  parser.on("--projects-dir DIR", "Directory of projects (default: current directory)") do |dir|
    options.projects_dir = dir
  end

  parser.on("--apps-dir DIR", "Directory to where the apps should be deployed (default: ENV['MULE_HOME']/apps)") do |dir|
    options.apps_dir = dir
  end
end.parse!

VERBOSE=options.verbose

def ensure_trailing_slash(path)
  path[-1] == '/' ? path : "#{path}/"
end

def remove_trailing_slash(path)
  path.chomp('/')
end

def watch_dirs(projects_dir)
  # Track current dir and one level down
  projects_dir=remove_trailing_slash(projects_dir)
  dirs=Dir["#{projects_dir}/*/src/main/mule"] + Dir["#{projects_dir}/src/main/mule"] + Dir["#{projects_dir}/*/src/main/resources"] + Dir["#{projects_dir}/src/main/resources"]
  puts "Watching directories : #{dirs}" if VERBOSE
  dirs
end

def extract_project_name_from_pom(pom_file_path)
  document = Document.new(File.read(pom_file_path))
  project_name = XPath.first(document, '//project/name')

  if project_name
    puts "Project Name: #{project_name.text}" if VERBOSE
    return project_name.text
  else
    puts "ERROR: No <name> element found in the pom.xml"
  end
end

def extract_project_name_from_filepath(path)
  pom_file="#{extract_project_root_from_path(path)}/pom.xml"
  extract_project_name_from_pom(pom_file)
end

# The name of this function if not very good
def extract_sub_dirs(path)
  # Pattern matches the dirs after /src/main/mule|resource but before the file
  match = path.match(%r{/src/main/(mule|resources)(/.+)/[^/]+$})
  path=match ? ensure_trailing_slash(match[2]) : nil
end

def extract_project_root_from_path(path)
  match = path.match(/(.*)\/src\/main\/(mule|resources)\//)
  if match
    project_root = match[1] # The captured group before `/src/main/mule/`
    puts "Project root: #{project_root}" if VERBOSE
    return project_root
  else
    puts "ERROR: Pattern not found in path"
  end
end

# Do we need this or can we use rebuild_mule_artifact()
def force_redeploy(application_path)
  # Find the first XML file, any xml will do just fine
  xml_file = Dir.glob(File.join(application_path, '*.xml')).first

  if xml_file
    # "Touch" the found XML file
    FileUtils.touch(xml_file)
    puts "Force redeploy by touching file: #{xml_file}" if VERBOSE
  else
    puts "WARN: No *.xml files found in the mule directory."
  end
end

def resources_file?(file_path)
  file_path.include?('src/main/resources')
end

def log4j2_file?(file_path)
  File.basename(file_path).downcase == 'log4j2.xml'
end

def contains_monitor_interval?(file_path)
  xml_data = File.read(file_path)
  document = Document.new(xml_data)
  configuration = document.elements['/Configuration']
  !configuration.attributes['monitorInterval'].nil?
end

def ignore_file?(file)    
  if ['target/', 'bin/', '.mule/', 'weave/autogenerated','.git/'].any? { |ignore| file.include?(ignore) }
    puts "Ignoring #{file}" if VERBOSE
    return true
  end
end

def rebuild_mule_artifact(project_dir,app_dir)
  file_path = "#{app_dir}/META-INF/mule-artifact/mule-artifact.json"
  json_data = File.read(file_path)
  data = JSON.parse(json_data)

  mule_xml_path = "#{project_dir}/src/main/mule/"   
  mule_xml_files = Dir.glob(File.join(mule_xml_path, '**', '*.xml')).select { |file| File.file?(file) }
  # Make paths relative to the resources_path
  mule_xml_files = mule_xml_files.map { |file| file.sub(mule_xml_path, '') }

  resources_path = "#{project_dir}/src/main/resources/"   
  resources_files = Dir.glob(File.join(resources_path, '**', '*')).select { |file| File.file?(file) }
  resources_files = resources_files.map { |file| file.sub(resources_path, '') }

  # Update config json
  data['configs'] = mule_xml_files
  data['classLoaderModelLoaderDescriptor']['attributes']['exportedResources'] = mule_xml_files + resources_files

  File.open(file_path, 'w') do |f|
    f.write(JSON.pretty_generate(data))
  end

  puts "Rebuilt mule-artifact.json"
end

def hash_dependencies(xml_content)
  document = REXML::Document.new(xml_content)
  dependencies_text = ""
  document.elements.to_a("//dependency/*").sort_by {|d| d.to_s}.each do |dependency|
    dependencies_text+= dependency.to_s
  end

  # Since dependencies can be defined in the parent pom we include this as well
  parent_text = ""
  document.elements.to_a("//parent/*").sort_by {|d| d.to_s}.each do |parent|
    parent_text+= parent.to_s
  end

  Digest::SHA256.hexdigest(dependencies_text++parent_text)
end

def initialize_pom_state(projects_dir)
  pom_state = {}
  projects_dir=remove_trailing_slash(projects_dir)
  (Dir.glob("#{projects_dir}/pom.xml") + Dir.glob("#{projects_dir}/*/pom.xml")).each do |pom_file|
    next if ignore_file?(pom_file)
    xml_content = File.read(pom_file)
    dependencies_hash = hash_dependencies(xml_content)
    pom_state[pom_file] = dependencies_hash
  end
  pom_state
end

def rebuild_project(pom_file,apps_dir,notification)
  project_root=File.dirname(pom_file)
  project_name=extract_project_name_from_pom(pom_file)
  send_notification('üîÑ', "Rebuilding: #{project_name}") if notification
  IO.popen("cd #{project_root};mvn clean package -DskipTests && cp target/#{project_name}*.jar #{apps_dir}/#{project_name}.jar") do |io|
    io.each do |line|
      puts line
    end
    io.close
  end
  exit_status = $?.exitstatus
  if exit_status == 0
    puts "Maven build executed successfully, redeploying app #{project_name}"
    send_notification('‚úÖ', "Build: #{project_name} succeeded") if notification
  else
    puts "Maven build failed with exit status #{exit_status}"
    send_notification('‚ùå', "Build: #{project_name} failed") if notification
  end
end

def send_notification(title, message)
  system "mule-reactor-notifier \"#{title}\" \"#{message}\"" 
end

def watch_mule_and_resource_dirs(apps_dir,projects_dir)
  listener = Listen.to(*watch_dirs(projects_dir)) do |modified, added, removed|
    puts "Changes detected" if VERBOSE

    modified.each do |file|
      next if ignore_file?(file)

      app_dir = "#{apps_dir}/#{extract_project_name_from_filepath(file)}"
      destination_dir = "#{app_dir}/#{extract_sub_dirs(file)}"

      puts "Modified: #{file}" if VERBOSE
      puts "Destination dir #{destination_dir}" if VERBOSE
      puts "Sub dir name: #{extract_sub_dirs(file)}" if VERBOSE

      unless Dir.exist?(app_dir)
        puts "No app deployed in: #{app_dir} Will not update"
        next
      end

      unless Dir.exist?(destination_dir)
        puts "Created sub-dirs for #{destination_dir}"  
        FileUtils.mkdir_p(destination_dir)
      end

      FileUtils.cp(file, destination_dir, noop: false, verbose: VERBOSE)
      puts "Updated: #{file} in #{destination_dir}"

      if log4j2_file?(file) && contains_monitor_interval?(file)
        puts "Skipping forced re-deploy because log4j2.xml contains monitorInterval"
      elsif resources_file?(file)
        force_redeploy(app_dir)
      end
    end

    added.each do |file|
      next if ignore_file?(file)
      app_dir = "#{apps_dir}/#{extract_project_name_from_filepath(file)}"
      destination_dir = "#{app_dir}/#{extract_sub_dirs(file)}"

      unless Dir.exist?(app_dir)
        puts "No app deployed in: #{app_dir} Will not update"
        next
      end

      unless Dir.exist?(destination_dir)
        puts "Created sub-dirs for #{destination_dir}"  
        FileUtils.mkdir_p(destination_dir)
      end

      FileUtils.cp(file, destination_dir, noop: false, verbose: VERBOSE)
      puts "Added: #{file} in #{destination_dir}"
      # This will force a redeploy 
      rebuild_mule_artifact(extract_project_root_from_path(file),app_dir)
    end

    removed.each do |file|
      next if ignore_file?(file)
      app_dir = "#{apps_dir}/#{extract_project_name_from_filepath(file)}"
      destination_dir = "#{apps_dir}/#{extract_project_name_from_filepath(file)}#{extract_sub_dirs(file)}"
      delete_file="#{destination_dir}/#{File.basename(file)}"
      FileUtils.rm(delete_file,noop: false, verbose: VERBOSE)
      puts "Removed: #{delete_file}"
      # This will force a redeploy 
      rebuild_mule_artifact(extract_project_root_from_path(file),app_dir)
    end
  end

  listener.start
end

def watch_pom_files(projects_dir,apps_dir,notification)
  # We use filewatcher, that poll for changes, because using eventbase file listenter is to slow for large folder structures with lots of changes going on, 
  # for example when we run mvn clean package.
  # The problem is that I have not found an platform independent filewatcher the handles ignores in an efficent way

  puts "Tracking changes in pom.xml files" if VERBOSE
  pom_file_watcher=Filewatcher.new(["#{projects_dir}/pom.xml","#{projects_dir}/*/pom.xml"], exclude: ['target'], interval: 1.1)
  pom_state = initialize_pom_state(projects_dir)
  Thread.new do
    pom_file_watcher.watch do |changes|
      current_pom_state = {}
      changes.each do |filename, event|
        next if ignore_file?(filename)
        case event.to_s
        when 'updated'
          puts 'POM file updated'
          xml_content = File.read(filename)
          dependencies_hash = hash_dependencies(xml_content)
          current_pom_state[filename] = dependencies_hash
          puts "Last pom state: #{pom_state}" if VERBOSE
          if pom_state[filename] == nil
            puts "Change tracking new pom file: #{filename}" 
          elsif pom_state[filename] != dependencies_hash
            puts "Change detected in dependencies of pom file: #{filename}"
            rebuild_project(filename,apps_dir,notification)
          end
        when 'created'
          # TODO Should trigger a re-intialization of the mule and resource listener
          puts 'NOT IMPLEMENTED: POM file created'
        when 'deleted'
          puts 'NOT IMPLEMENTED: POM file deleted'
        end
        pom_state = current_pom_state
      end
    end
  end
end


def watch_deployments(apps_dir)
  puts "Deployment watching enabled" if VERBOSE
  log_file_path = "#{apps_dir}/..//logs/mule_ee.log"
  Thread.new do
    # TODO: This wont work on windows gem 'file-tail' could be an options
    Open3.popen3("tail -F #{log_file_path}") do |stdin, stdout, stderr, thread|
      stdout.each do |line|
        if match_data = line.match(/\* Started app ['"]([^'"]+)['"]/)
          app_name = match_data[1]
          send_notification('‚úÖ', "Deployment: #{app_name} succeeded")
        elsif match_data = line.match(/DeploymentException: Failed to deploy artifact \[([^\]]+)\]/)
          app_name = match_data[1]
          send_notification('‚ùå', "Deployment: #{app_name} failed")
        end
      end
    end
  end
end

def run(options)
  watch_mule_and_resource_dirs(options.apps_dir,options.projects_dir)
  watch_pom_files(options.projects_dir,options.apps_dir,options.notification) if options.watch_pom
  watch_deployments(options.apps_dir) if options.watch_deployments && options.notification

  puts "Mule apps directory: #{options.apps_dir}"
  puts "Monitoring for changes in: #{options.projects_dir}. Press Ctrl+C to stop."
  sleep
end

run(options) if __FILE__ == $PROGRAM_NAME

