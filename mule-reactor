#!/usr/bin/env ruby
require 'listen'
require 'fileutils'
require 'find'
require 'rexml/document'
include REXML
require 'json'
require 'optparse'
require 'ostruct'
require 'filewatcher'
require 'open3'


# TODOs and Ideas
# Would it be posible to skip deploy when the only formatting is changed?

# Initialize options with default values
$options = OpenStruct.new(verbose: false, watch_pom: false, notification: false, projects_dir: Dir.pwd, apps_dir: "#{ENV['MULE_HOME']}/apps")

OptionParser.new do |parser|
  parser.banner = "Usage: ruby #{File.basename(__FILE__)} [options]"

  parser.on("-h", "--help", "Display this help and exit") do
    puts parser
    exit
  end

  parser.on("--verbose", "Run script in verbose mode") do
    $options.verbose = true
  end

  parser.on("-n", "--notification", "Enable notifications") do
    $options.notification = true
  end

  parser.on("-p", "--watch-pom", "Detect changes in pom.xml and rebuild when relevant content has changed") do
    $options.watch_pom = true
  end

  parser.on("--projects-dir DIR", "Directory of projects (default: current directory)") do |dir|
    $options.projects_dir = dir
  end

  parser.on("--apps-dir DIR", "Directory to where the apps should be deployed (default: ENV['MULE_HOME']/apps)") do |dir|
    $options.apps_dir = dir
  end
end.parse!

puts "Mule apps directory: #{$options.apps_dir}"

def ensure_trailing_slash(path)
  path[-1] == '/' ? path : "#{path}/"
end

def remove_trailing_slash(path)
  path.chomp('/')
end

def watch_dirs(projects_dir=$options.projects_dir)
  # Track current dir and one level down
  projects_dir=remove_trailing_slash(projects_dir)
  dirs=Dir["#{projects_dir}/*/src/main/mule"] + Dir["#{projects_dir}/src/main/mule"] + Dir["#{projects_dir}/*/src/main/resources"] + Dir["#{projects_dir}/src/main/resources"]
  puts "Watching directories : #{dirs}" if $options.verbose
  dirs
end

def extract_project_name_from_pom(pom_file_path)
  document = Document.new(File.read(pom_file_path))
  project_name = XPath.first(document, '//project/name')

  if project_name
    puts "Project Name: #{project_name.text}" if $options.verbose
    return project_name.text
  else
    puts "ERROR: No <name> element found in the pom.xml"
  end
end

def extract_project_name_from_filepath(path)
  pom_file="#{extract_project_root_from_path(path)}/pom.xml"
  extract_project_name_from_pom(pom_file)
end

def extract_sub_dirs(path)
  # Pattern matches the dirs after /src/main/mule|resource but before the file
  match = path.match(%r{/src/main/(mule|resources)(/.+)/[^/]+$})
  path=match ? ensure_trailing_slash(match[2]) : nil
end

def extract_project_root_from_path(path)
  match = path.match(/(.*)\/src\/main\/(mule|resources)\//)
  if match
    project_root = match[1] # The captured group before `/src/main/mule/`
    puts "Project root: #{project_root}" if $options.verbose
    return project_root
  else
    puts "ERROR: Pattern not found in path"
  end
end

def force_redeploy(application_path)
  # Find the first XML file, any xml will do just fine
  xml_file = Dir.glob(File.join(application_path, '*.xml')).first

  if xml_file
    # "Touch" the found XML file
    FileUtils.touch(xml_file)
    puts "Force redeploy by touching file: #{xml_file}" if $options.verbose
  else
    puts "WARN: No *.xml files found in the mule directory."
  end
end

def resources_file?(file_path)
  file_path.include?('src/main/resources')
end

def log4j2_file?(file_path)
  File.basename(file_path).downcase == 'log4j2.xml'
end

def contains_monitor_interval?(file_path)
  xml_data = File.read(file_path)
  document = Document.new(xml_data)
  configuration = document.elements['/Configuration']
  !configuration.attributes['monitorInterval'].nil?
end

# TODO This should probaly ignore weave.autogenerated and /bin
def ignore_file?(file)    
  if file.include?('/target/')
    puts "Ignoring #{file}"
    return true
  end
end

def rebuild_mule_artifact(project_dir,app_dir)
  file_path = "#{app_dir}/META-INF/mule-artifact/mule-artifact.json"
  json_data = File.read(file_path)
  data = JSON.parse(json_data)

  # List all XML files in mule dir
  mule_xml_path = "#{project_dir}/src/main/mule/"   
  mule_xml_files = Dir.glob(File.join(mule_xml_path, '**', '*.xml')).select { |file| File.file?(file) }
  # Make paths relative to the resources_path
  mule_xml_files = mule_xml_files.map { |file| file.sub(mule_xml_path, '') }

  # List all resources files
  resources_path = "#{project_dir}/src/main/resources/"   
  resources_files = Dir.glob(File.join(resources_path, '**', '*')).select { |file| File.file?(file) }
  # Make paths relative to the resources_path
  resources_files = resources_files.map { |file| file.sub(resources_path, '') }

  # Update config json
  data['configs'] = mule_xml_files
  data['classLoaderModelLoaderDescriptor']['attributes']['exportedResources'] = mule_xml_files + resources_files

  # Write the updated JSON back to the mule-artifact.json file
  File.open(file_path, 'w') do |f|
    f.write(JSON.pretty_generate(data))
  end

  puts "Rebuilt mule-artifact.json"
end

def hash_dependencies(xml_content)
  document = REXML::Document.new(xml_content)
  dependencies_text = ""
  document.elements.to_a("//dependency/*").sort_by {|d| d.to_s}.each do |dependency|
    dependencies_text+= dependency.to_s
  end

  # Since dependencies can be defined in the parent pom we include this as well
  parent_text = ""
  document.elements.to_a("//parent/*").sort_by {|d| d.to_s}.each do |parent|
    parent_text+= parent.to_s
  end

  Digest::SHA256.hexdigest(dependencies_text++parent_text)
end

def initialize_pom_state(projects_dir)
  pom_state = {}
  projects_dir=remove_trailing_slash(projects_dir)
  (Dir.glob("#{projects_dir}/pom.xml") + Dir.glob("#{projects_dir}/*/pom.xml")).each do |pom_file|
    next if File.directory?(pom_file) # Skip directories just in case
    xml_content = File.read(pom_file)
    dependencies_hash = hash_dependencies(xml_content)
    pom_state[pom_file] = dependencies_hash
  end
  pom_state
end

def send_notification(title, message)
  system "mule-reactor-notifier \"#{title}\" \"#{message}\"" 
end

# Set up a listener for the projects directory
listener = Listen.to(*watch_dirs) do |modified, added, removed|
  puts "Changes detected" if $options.verbose

  modified.each do |file|
    next if ignore_file?(file)

    app_dir = "#{$options.apps_dir}/#{extract_project_name_from_filepath(file)}"
    destination_dir = "#{app_dir}/#{extract_sub_dirs(file)}"

    puts "Modified: #{file}" if $options.verbose
    puts "Destination dir #{destination_dir}" if $options.verbose
    puts "Sub dir name: #{extract_sub_dirs(file)}" if $options.verbose
    
    unless Dir.exist?(app_dir)
      puts "No app deployed in: #{app_dir} Will not update"
      next
    end

    unless Dir.exist?(destination_dir)
      puts "Created sub-dirs for #{destination_dir}"  
      FileUtils.mkdir_p(destination_dir)
    end

    FileUtils.cp(file, destination_dir, noop: false, verbose: $options.verbose)
    puts "Updated: #{file} in #{destination_dir}"

    if log4j2_file?(file) && contains_monitor_interval?(file)
      puts "Skipping forced re-deploy because log4j2.xml contains monitorInterval"
    elsif resources_file?(file)
      force_redeploy(app_dir)
    end
  end

  added.each do |file|
    next if ignore_file?(file)
    app_dir = "#{$options.apps_dir}/#{extract_project_name_from_filepath(file)}"
    destination_dir = "#{app_dir}/#{extract_sub_dirs(file)}"

    unless Dir.exist?(app_dir)
      puts "No app deployed in: #{app_dir} Will not update"
      next
    end

    unless Dir.exist?(destination_dir)
      puts "Created sub-dirs for #{destination_dir}"  
      FileUtils.mkdir_p(destination_dir)
    end

    FileUtils.cp(file, destination_dir, noop: false, verbose: $options.verbose)
    puts "Added: #{file} in #{destination_dir}"
    # This will force a redeploy 
    rebuild_mule_artifact(extract_project_root_from_path(file),app_dir)
  end

  removed.each do |file|
    next if ignore_file?(file)
    app_dir = "#{$options.apps_dir}/#{extract_project_name_from_filepath(file)}"
    destination_dir = "#{$options.apps_dir}/#{extract_project_name_from_filepath(file)}#{extract_sub_dirs(file)}"
    delete_file="#{destination_dir}/#{File.basename(file)}"
    FileUtils.rm(delete_file,noop: false, verbose: $options.verbose)
    puts "Removed: #{delete_file}"
    # This will force a redeploy 
    rebuild_mule_artifact(extract_project_root_from_path(file),app_dir)
  end

end

listener.start # Start listening to file changes

if $options.watch_pom
  puts "Tracking changes in pom.xml files" if $options.verbose
  # We use filewatcher, that poll for changes, because using eventbase file listenter is to slow for large folder structures with lots of changes going on, 
  # for example when we run mvn clean package.
  # Start watching pom.xml for changes
  pom_file_watcher=Filewatcher.new(["#{$options.projects_dir}/pom.xml","#{$options.projects_dir}/*/pom.xml"], exclude: ['target'], interval: 0.5)
  pom_state = initialize_pom_state($options.projects_dir)
  Thread.new do
    pom_file_watcher.watch do |changes|
      current_pom_state = {}
      changes.each do |filename, event|
        case event.to_s # Ensure matching as string, adjust based on debug output
        when 'updated'
          puts 'POM file updated'
          xml_content = File.read(filename)
          dependencies_hash = hash_dependencies(xml_content)
          current_pom_state[filename] = dependencies_hash
          puts "Last pom state: #{pom_state}" if $options.verbose
          if pom_state[filename] == nil
            puts "Change tracking new pom file: #{filename}" 
          elsif pom_state[filename] != dependencies_hash
            puts "Change detected in dependencies of pom file: #{filename}"
            project_root=File.dirname(filename)
            project_name=extract_project_name_from_pom(filename)
            send_notification('üîÑ', "Rebuilding #{project_name}") if $options.notification
            IO.popen("cd #{project_root};mvn clean package -DskipTests && cp target/#{project_name}*.jar #{$options.apps_dir}/#{project_name}.jar") do |io|
              io.each do |line|
                puts line
              end
              io.close
            end
            exit_status = $?.exitstatus
            if exit_status == 0
              puts "Maven build executed successfully, redeploying app #{project_name}"
              send_notification('‚úÖ', "Build of #{project_name} succeeded") if $options.notification
            else
              puts "Maven build failed with exit status #{exit_status}"
              send_notification('‚ùå', "Build of #{project_name} failed") if $options.notification
            end
          end
        when 'created'
          # TODO Should trigger a re-intialization of the mule and resource listener
          puts 'NOT IMPLEMENTED: POM file created'
        when 'deleted'
          puts 'NOT IMPLEMENTED: POM file deleted'
        end
        pom_state = current_pom_state
      end
    end
  end
end


if $options.notification
  puts "Notifications enabled" if $options.verbose
  log_file_path = "#{$options.apps_dir}/..//logs/mule_ee.log"
  Thread.new do
    Open3.popen3("tail -F #{log_file_path}") do |stdin, stdout, stderr, thread|
      stdout.each do |line|
        if match_data = line.match(/\* Started app ['"]([^'"]+)['"]/)
          app_name = match_data[1]
          send_notification('‚úÖ', "Application #{app_name} started")
        elsif match_data = line.match(/DeploymentException: Failed to deploy artifact \[([^\]]+)\]/)
          app_name = match_data[1]
          send_notification('‚ùå', "Application #{app_name} failed to deploy")
        end
      end
    end
  end
end

puts "Monitoring for changes in: #{$options.projects_dir}. Press Ctrl+C to stop."
sleep
