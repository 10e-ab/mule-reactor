#!/usr/bin/env ruby
require 'listen'
require 'fileutils'
require 'find'
require 'rexml/document'
include REXML
require 'json'
require 'optparse'
require 'ostruct'
require 'filewatcher'
require 'open3'
require 'diffy'
require 'pathname'
require 'stringio'


# TODO/Ideas
# * Improve error handling
# * Document the new formatting and whitespace feature
# * There is a lot of options/flags. Maybe remove some, negate others or add a -s --sensible for sensible defaults.
# * Create a jruby/java version that can be used on sites that don't allow ruby
# * Make a distinction between VERBOSE and DEBUG
# * If the list of changes contains a pom.xml and that triggers a rebuild, we should not hot deploy
# * Add test if apps folder exists
# * If a build failes, we should try to rebuild instead of redeploy
# * There is a bug that causes rebuilds when pom.xml are updated

# Initialize options with default values
options = OpenStruct.new(verbose: false, watch_pom: false, notification: false, ignore_formatting: true,ignore_blank_lines: true,ignore_whitespace: true, watch_deployments: false,follow_symlinks: false,projects_dir: Dir.pwd, apps_dir: "#{ENV['MULE_HOME']}/apps", symlink_interval: 1.1, pom_interval: 1.1)

OptionParser.new do |parser|
  parser.banner = "Usage: ruby #{File.basename(__FILE__)} [options]"

  parser.on("-h", "--help", "Display this help and exit") do
    puts parser
    exit
  end

  parser.on("-v", "--verbose", "Run script in verbose mode") do
    options.verbose = true
  end

  parser.on("-n", "--notification", "Enable notifications") do
    options.notification = true
  end

  parser.on("-d", "--watch-deployments", "Will tail the sever-log and notify on deployment status. Notification must be enable and this might not work on windows") do
    options.watch_deployments = true
  end

  parser.on("-p", "--watch-pom", "Detect changes in pom.xml and rebuild when relevant content has changed") do
    options.watch_pom = true
  end

  parser.on("--no-ignore-formatting", "Considers changes in formatting for JSON and XML files.") do
    options.ignore_formatting = false
  end

  parser.on("--no-ignore-whitespace", "Considers whitespace changes in all file types.") do
    options.ignore_whitespace = false
  end

  parser.on("--no-ignore-blank-lines", "Considers blank lines in all file types during comparison.") do
    options.ignore_blank_lines = false
  end

  parser.on("--projects-dir DIR", "Directory of projects (default: current directory)") do |dir|
    options.projects_dir = dir
  end

  parser.on("--apps-dir DIR", "Directory to where the apps should be deployed (default: ENV['MULE_HOME']/apps)") do |dir|
    options.apps_dir = dir
  end

  parser.on("-s", "--follow-symlinks", "Follow symbolic links using hybrid approach (Listen + Filewatcher for external symlinks)") do
    options.follow_symlinks = true
  end

  parser.on("--symlink-interval SECONDS", Float, "Polling interval for symlink watcher in seconds (default: 1.1)") do |interval|
    options.symlink_interval = interval
  end

  parser.on("--pom-interval SECONDS", Float, "Polling interval for pom.xml watcher in seconds (default: 1.1)") do |interval|
    options.pom_interval = interval
  end
end.parse!

VERBOSE=options.verbose

def ensure_trailing_slash(path)
  path[-1] == '/' ? path : "#{path}/"
end

def remove_trailing_slash(path)
  path.chomp('/')
end

def detect_symlinks_in_directories(dirs)
  symlink_paths = []  # The actual symlink paths to watch
  
  dirs.each do |dir|
    next unless Dir.exist?(dir)
    
    Find.find(dir) do |path|
      if File.symlink?(path)
        target = File.readlink(path)
        absolute_target = File.expand_path(target, File.dirname(path))
        watched_dir = File.expand_path(dir)
        is_external = !absolute_target.start_with?(watched_dir)
        
        if is_external
          # Add the specific symlink path, not the entire parent directory
          if File.directory?(absolute_target)
            symlink_paths << path
          else
            # For file symlinks, add the parent directory of the symlink
            symlink_paths << File.dirname(path)
          end
        end
        
        Find.prune if File.directory?(absolute_target)
      end
    end
  end
  
  symlink_paths.uniq
end

def watch_dirs(projects_dir)
  # Track current dir and one level down
  projects_dir=remove_trailing_slash(projects_dir)
  dirs=Dir["#{projects_dir}/*/src/main/mule"] + Dir["#{projects_dir}/src/main/mule"] + Dir["#{projects_dir}/*/src/main/resources"] + Dir["#{projects_dir}/src/main/resources"]
  puts "Watching directories : #{dirs}" if VERBOSE
  dirs
end

def extract_project_name_from_pom(pom_file_path)
  document = Document.new(File.read(pom_file_path))
  project_name = XPath.first(document, '//project/name')

  if project_name
    puts "Project Name: #{project_name.text}" if VERBOSE
    return project_name.text
  else
    puts "ERROR: No <name> element found in the pom.xml"
  end
end

def extract_project_name_from_filepath(path)
  project_root = extract_project_root_from_path(path)
  return nil unless project_root
  
  pom_file="#{project_root}/pom.xml"
  extract_project_name_from_pom(pom_file)
end

def app_sub_dirs(path)
  # Pattern matches the dirs after /src/main/mule|resource but before the file
  match = path.match(%r{/src/main/(mule|resources)(/.+)/[^/]+$})
  path=match ? ensure_trailing_slash(match[2]) : nil
end

def extract_project_root_from_path(path)
  match = path.match(/(.*)\/src\/main\/(mule|resources)\//)
  if match
    project_root = match[1] # The captured group before `/src/main/mule/`
    puts "Project root: #{project_root}" if VERBOSE
    return project_root
  else
    puts "ERROR: Pattern not found in path"
  end
end

def resources_file?(file_path)
  file_path.include?('src/main/resources')
end

def log4j2_file?(file_path)
  File.basename(file_path).downcase == 'log4j2.xml'
end

def contains_monitor_interval?(file_path)
  xml_data = File.read(file_path)
  document = Document.new(xml_data)
  configuration = document.elements['/Configuration']
  !configuration.attributes['monitorInterval'].nil?
end

def ignore_file?(file)
  # List of directory names or patterns to ignore
  ignores = ['target/', 'bin/', '.mule/', 'weave/autogenerated', '.git/']

  # Check if file includes any of the ignores or ends with .orig
  if ignores.any? { |ignore| file.include?(ignore) } || file.end_with?('.orig')
    puts "Ignoring #{file}" if VERBOSE
    return true
  end
  false
end

# This will trigger a redeploy
def rebuild_mule_artifact(project_dir,app_dir,notification)
  project_name=File.basename(project_dir.chomp('/'))
  send_notification('üîÑ', "Re-deploying: #{project_name}") if notification
  file_path = "#{app_dir}/META-INF/mule-artifact/mule-artifact.json"
  json_data = File.read(file_path)
  data = JSON.parse(json_data)

  mule_xml_path = "#{project_dir}/src/main/mule/"   
  mule_xml_files = Dir.glob(File.join(mule_xml_path, '**', '*.xml')).select { |file| File.file?(file) }
  # Make paths relative to the resources_path
  mule_xml_files = mule_xml_files.map { |file| file.sub(mule_xml_path, '') }

  resources_path = "#{project_dir}/src/main/resources/"   
  resources_files = Dir.glob(File.join(resources_path, '**', '*')).select { |file| File.file?(file) }
  resources_files = resources_files.map { |file| file.sub(resources_path, '') }

  # Update config json
  data['configs'] = mule_xml_files
  data['classLoaderModelLoaderDescriptor']['attributes']['exportedResources'] = mule_xml_files + resources_files

  File.open(file_path, 'w') do |f|
    f.write(JSON.pretty_generate(data))
  end
  puts "Rebuilt mule-artifact.json"
end

def hash_dependencies(xml_content)
  document = REXML::Document.new(xml_content)
  dependencies_text = ""
  formatted_content = ""

  # Group dependency elements by parent dependency
  document.elements.each("//dependency") do |dependency|
    formatted_content += "\n<dependency>\n"
    dependency.elements.sort_by {|e| e.to_s}.each do |element|
      formatted_content += "  #{element}\n"
      dependencies_text += element.to_s
    end
    formatted_content += "</dependency>\n"
  end

  # Since dependencies can be defined in the parent pom we include any changes to the parent
  parent_text = ""
  document.elements.each("//parent") do |parent|
    formatted_content += "\n<parent>\n"
    parent.elements.sort_by {|e| e.to_s}.each do |element|
      formatted_content += "  #{element}\n"
      parent_text += element.to_s
    end
    formatted_content += "</parent>\n"
  end

  combined_text = dependencies_text + parent_text
  {
    hash: Digest::SHA256.hexdigest(combined_text),
    content: formatted_content
  }
end

def initialize_pom_state(projects_dir)
  pom_state = {}
  projects_dir=remove_trailing_slash(projects_dir)
  (Dir.glob("#{projects_dir}/pom.xml") + Dir.glob("#{projects_dir}/*/pom.xml")).each do |pom_file|
    next if ignore_file?(pom_file)
    xml_content = File.read(pom_file)
    pom_state[pom_file] = hash_dependencies(xml_content)
  end
  pom_state
end

def rebuild_project(pom_file,apps_dir,notification)
  project_root=File.dirname(pom_file)
  project_name=extract_project_name_from_pom(pom_file)
  send_notification('üõ†Ô∏è', "Rebuilding: #{project_name}") if notification
  # TODO: This wont work on windows
  # TODO: Make the build command configurable
  IO.popen("cd #{project_root};mvn clean package -DskipTests && cp target/#{project_name}*.jar #{apps_dir}/#{project_name}.jar") do |io|
    io.each { |line| puts line }
    io.close
  end
  exit_status = $?.exitstatus
  if exit_status == 0
    puts "Maven build executed successfully, redeploying app #{project_name}"
    send_notification('üõ†Ô∏è ‚úÖ', "Build: #{project_name} succeeded") if notification
  else
    puts "Maven build failed with exit status #{exit_status}"
    send_notification('üõ†Ô∏è ‚ùå', "Build: #{project_name} failed") if notification
  end
end

def send_notification(title, message)
  system "mule-reactor-notifier \"#{title}\" \"#{message}\"" 
end

def app_deployed?(app_dir)
  app_name = Pathname.new(app_dir).basename.to_s
  anchor_file=File.join(app_dir, '../' ,app_name++'-anchor.txt')
  if Dir.exist?(app_dir)
    return true
  else
    puts "No app deployed in: #{app_dir} Will not update" if VERBOSE
    return false
  end
end

def create_destination_sub_dirs_if_missing(destination_dir)
  unless Dir.exist?(destination_dir)
    puts "Created sub-dirs for #{destination_dir}"  
    FileUtils.mkdir_p(destination_dir)
  end
end

# Test if the changes are only formatting or white spaces
def significant_changes?(updated_file,current_file,ignore_formatting,ignore_whitespace,ignore_blank_lines)
  return true unless ignore_formatting || ignore_whitespace || ignore_blank_lines

  begin
    return true unless File.exist?(updated_file) && File.exist?(current_file)

    # Define a size threshold of 1MB
    size_threshold = 1 * 1024 * 1024

    # Check the size of both files
    return true if File.size(updated_file) > size_threshold || File.size(current_file) > size_threshold

    current_content=""
    updated_content=""

    # Format xml and json before diffing
    # TODO: Add support for dwl files, this is a bit hard because no formatter exists
    if ignore_formatting
      puts "Formatting XML and JSON before diff" if VERBOSE
      case File.extname(updated_file).downcase
      when ".xml"
        updated_document = REXML::Document.new(File.new(updated_file))
        current_document = REXML::Document.new(File.new(current_file))
        formatter = REXML::Formatters::Pretty.new(2)
        formatter.compact = true
        updated_io = StringIO.new
        current_io = StringIO.new
        formatter.write(updated_document, updated_io)
        formatter.write(current_document, current_io)
        updated_content = updated_io.string
        current_content = current_io.string
      when ".json"
        updated_content = JSON.pretty_generate(JSON.parse(File.read(updated_file)))
        current_content = JSON.pretty_generate(JSON.parse(File.read(current_file)))
      else
        current_content = File.read(current_file)
        updated_content = File.read(updated_file)
      end
    else
      current_content = File.read(current_file)
      updated_content = File.read(updated_file)
    end


    options=""
    options+="w" if ignore_whitespace
    options+="B" if ignore_blank_lines
    diff_options=options.empty? ? nil : "-#{options}"

    diff = Diffy::Diff.new(current_content, updated_content, :diff => diff_options, :allow_empty_diff => true, :include_plus_and_minus_in_html => false)
    puts "Diff: #{diff}" if VERBOSE

    diff.any? 
  rescue REXML::ParseException => e
    puts "Error parsing XML: #{e.message}"
  rescue JSON::ParserError => e
    puts "Error parsing JSON: #{e.message}"
    return true # or false, depending on how you want to handle parsing errors
  rescue  => e
    puts "Error diffing files: #{e.message}"
    return true # or false, depending on how you want to handle parsing errors
  end
end


def handle_file_change(file, event, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification)
  return if ignore_file?(file)
  
  project_name = extract_project_name_from_filepath(file)
  unless project_name
    puts "WARNING: Could not determine project name for: #{file}" if VERBOSE
    return
  end
  
  app_dir = "#{apps_dir}/#{project_name}"
  return unless app_deployed?(app_dir)
  
  case event
  when :modified
    destination_dir = "#{app_dir}/#{app_sub_dirs(file)}"
    create_destination_sub_dirs_if_missing(destination_dir)
    puts "Destination dir #{destination_dir}" if VERBOSE
    
    # Check if it's a directory
    if File.directory?(file)
      puts "Skipping directory modification: #{file}" if VERBOSE
      return
    end
    
    unless significant_changes?(file,"#{destination_dir}/#{File.basename(file)}",ignore_formatting,ignore_whitespace,ignore_blank_lines)
      puts "No significant change, will not update"
      return
    end
    
    FileUtils.cp(file, destination_dir, noop: false, verbose: VERBOSE)
    puts "Updated: #{file} in #{destination_dir}"
    
    if log4j2_file?(file) && contains_monitor_interval?(file)
      puts "Skipping forced re-deploy because log4j2.xml contains monitorInterval"
    else
      project_root = extract_project_root_from_path(file)
      rebuild_mule_artifact(project_root,app_dir,notification) if project_root
    end
    puts "Updated: #{file}" if VERBOSE
    
  when :added
    destination_dir = "#{app_dir}/#{app_sub_dirs(file)}"
    create_destination_sub_dirs_if_missing(destination_dir)
    
    # Check if it's a directory
    if File.directory?(file)
      # Create the directory in the destination
      FileUtils.mkdir_p("#{destination_dir}/#{File.basename(file)}", noop: false, verbose: VERBOSE)
      puts "Created directory: #{file} in #{destination_dir}"
    else
      FileUtils.cp(file, destination_dir, noop: false, verbose: VERBOSE)
      puts "Added: #{file} in #{destination_dir}"
    end
    
    project_root = extract_project_root_from_path(file)
    rebuild_mule_artifact(project_root,app_dir,notification) if project_root
    
  when :removed
    destination_dir = "#{app_dir}#{app_sub_dirs(file)}"
    delete_path="#{destination_dir}/#{File.basename(file)}"
    
    # Check if it's a directory
    if File.directory?(delete_path)
      FileUtils.rm_rf(delete_path, noop: false, verbose: VERBOSE)
      puts "Removed directory: #{delete_path}"
    elsif File.exist?(delete_path)
      FileUtils.rm(delete_path, noop: false, verbose: VERBOSE)
      puts "Removed: #{delete_path}"
    end
    
    project_root = extract_project_root_from_path(file)
    rebuild_mule_artifact(project_root,app_dir,notification) if project_root
  end
end

def watch_mule_and_resources_hybrid(apps_dir,projects_dir,ignore_formatting,ignore_whitespace,ignore_blank_lines,notification,follow_symlinks,symlink_interval)
  unless Dir.exist?(apps_dir)
    puts "Directory #{apps_dir} does not exist"
    puts "Make sure that MULE_HOME is set and points to an existing mule-server directory, or specify the --apps-dir script option"
    exit 1
  end

  unless Dir.exist?(projects_dir)
    puts "Directory #{projects_dir} does not exist"
    puts "Make sure that --project-dir points to an existing directory"
    exit 1
  end

  dirs = watch_dirs(projects_dir)
  
  if follow_symlinks
    symlink_paths = detect_symlinks_in_directories(dirs)
    
    if symlink_paths.any?
      # Use Listen for all original directories (it will ignore external symlinks)
      listener = Listen.to(*dirs) do |modified, added, removed|
        puts "Changes detected (Listen)" if VERBOSE
        modified.each { |file| handle_file_change(file, :modified, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification) }
        added.each { |file| handle_file_change(file, :added, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification) }
        removed.each { |file| handle_file_change(file, :removed, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification) }
      end
      listener.start
      
      # Use Filewatcher only for the specific symlink paths
      patterns = symlink_paths.map { |path| "#{path}/**/*" }
      
      puts "Detected external symlinks:" if VERBOSE
      symlink_paths.each do |path|
        puts "  #{path}" if VERBOSE
      end
      
      # Store patterns and thread reference for monitoring
      @filewatcher_patterns = patterns
      @filewatcher_last_detection = Time.now
      
      # Function to start the filewatcher thread
      start_filewatcher = lambda do
        @filewatcher_thread = Thread.new do
          begin
            puts "[#{Time.now}] Starting Filewatcher thread for symlink paths..." if VERBOSE
            
            filewatcher = Filewatcher.new(@filewatcher_patterns, interval: symlink_interval)
            filewatcher.watch do |changes|
              @filewatcher_last_detection = Time.now
              puts "[#{Time.now}] Changes detected (Filewatcher): #{changes.inspect}" if VERBOSE
              
              changes.each do |filename, event|
                begin
                  puts "Filewatcher processing: #{event} - #{filename}" if VERBOSE
                  
                  mapped_event = case event
                                when :created then :added
                                when :updated then :modified
                                when :deleted then :removed
                                else event
                                end
                  handle_file_change(filename, mapped_event, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification)
                rescue => e
                  puts "ERROR processing file #{filename}: #{e.message}"
                  puts e.backtrace.join("\n") if VERBOSE
                  # Continue processing other files
                end
              end
            end
          rescue => e
            puts "ERROR: Filewatcher thread crashed: #{e.message}"
            puts e.backtrace.join("\n") if VERBOSE
          ensure
            puts "[#{Time.now}] Filewatcher thread terminated" if VERBOSE
          end
        end
      end
      
      # Start the initial filewatcher thread
      start_filewatcher.call
      
      # Monitor thread to check and restart if needed
      Thread.new do
        loop do
          sleep 100  # Check every 100 seconds
          
          if @filewatcher_thread && !@filewatcher_thread.alive?
            puts "[#{Time.now}] WARNING: Filewatcher thread died, restarting..." if VERBOSE
            start_filewatcher.call
          elsif VERBOSE && @filewatcher_thread && @filewatcher_thread.alive?
            time_since_last = Time.now - @filewatcher_last_detection
            if time_since_last > 300  # Log if no activity for 5 minutes
              puts "[#{Time.now}] Filewatcher thread alive, last detection #{time_since_last.to_i}s ago"
            end
          end
        rescue => e
          puts "ERROR in monitor thread: #{e.message}"
          puts e.backtrace.join("\n") if VERBOSE
        end
      end
    else
      puts "No external symlinks detected. Using Listen only." if VERBOSE
      start_listen_watcher(dirs, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification)
    end
  else
    start_listen_watcher(dirs, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification)
  end
end

def start_listen_watcher(dirs, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification)
  listener = Listen.to(*dirs) do |modified, added, removed|
    puts "Changes detected" if VERBOSE
    modified.each { |file| handle_file_change(file, :modified, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification) }
    added.each { |file| handle_file_change(file, :added, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification) }
    removed.each { |file| handle_file_change(file, :removed, apps_dir, ignore_formatting, ignore_whitespace, ignore_blank_lines, notification) }
  end
  listener.start
end

# Kept for backwards compatibility - redirects to hybrid version
def watch_mule_and_resources_listener(apps_dir,projects_dir,ignore_formatting,ignore_whitespace,ignore_blank_lines,notification)
  watch_mule_and_resources_hybrid(apps_dir,projects_dir,ignore_formatting,ignore_whitespace,ignore_blank_lines,notification,false,1.1)
end

def watch_pom_files(projects_dir,apps_dir,notification,pom_interval)
  # We use filewatcher, that polls for changes, because using eventbase file listenter is to slow for large folder structures with lots of changes going on, 
  # for example when we run mvn clean package.
  # I have not found an platform independent filewatcher the handles ignore in an efficent way

  puts "Tracking changes in pom.xml files" if VERBOSE
  patterns = ["#{projects_dir}/pom.xml","#{projects_dir}/*/pom.xml"]
  pom_state = initialize_pom_state(projects_dir)
  @pom_watcher_last_detection = Time.now
  
  # Function to start the pom watcher thread
  start_pom_watcher = lambda do
    @pom_watcher_thread = Thread.new do
      begin
        puts "[#{Time.now}] Starting POM file watcher thread..." if VERBOSE
        pom_file_watcher = Filewatcher.new(patterns, exclude: ['target'], interval: pom_interval)
        
        pom_file_watcher.watch do |changes|
          @pom_watcher_last_detection = Time.now
          puts "[#{Time.now}] POM changes detected: #{changes.keys.join(', ')}" if VERBOSE
          
          current_pom_state = {}
          changes.each do |filename, event|
            begin
              next if ignore_file?(filename)
              app_dir = "#{apps_dir}/#{extract_project_name_from_pom(filename)}"
              next unless app_deployed?(app_dir)
              
              case event.to_s
              when 'updated'
                puts 'POM file updated'
                xml_content = File.read(filename)
                new_state = hash_dependencies(xml_content)
                current_pom_state[filename] = new_state
                puts "Last pom state hash: #{pom_state[filename][:hash]}" if VERBOSE
                # This should not really happen, could probably be removed
                if pom_state[filename] == nil
                  puts "Change tracking new pom file: #{filename}"
                elsif pom_state[filename][:hash] != new_state[:hash]
                  puts "Change detected in dependencies of pom file: #{filename}"
                  if VERBOSE
                    diff = Diffy::Diff.new(pom_state[filename][:content], new_state[:content], :allow_empty_diff => true, :include_plus_and_minus_in_html => false)
                    puts "POM Diff:\n#{diff}"
                  end
                  rebuild_project(filename,apps_dir,notification)
                end
              when 'created'
                # TODO Should trigger a re-intialization of the mule and resource listener
                puts 'NOT IMPLEMENTED: POM file created'
              when 'deleted'
                puts 'NOT IMPLEMENTED: POM file deleted'
              end
            rescue => e
              puts "ERROR processing POM file #{filename}: #{e.message}"
              puts e.backtrace.join("\n") if VERBOSE
              # Continue processing other files
            end
          end
          pom_state.merge!(current_pom_state) if current_pom_state.any?
        end
      rescue => e
        puts "ERROR: POM watcher thread crashed: #{e.message}"
        puts e.backtrace.join("\n") if VERBOSE
      ensure
        puts "[#{Time.now}] POM watcher thread terminated" if VERBOSE
      end
    end
  end
  
  # Start the initial pom watcher thread
  start_pom_watcher.call
  
  # Monitor thread to check and restart if needed
  Thread.new do
    loop do
      sleep 100  # Check every 100 seconds
      
      if @pom_watcher_thread && !@pom_watcher_thread.alive?
        puts "[#{Time.now}] WARNING: POM watcher thread died, restarting..." if VERBOSE
        start_pom_watcher.call
      elsif VERBOSE && @pom_watcher_thread && @pom_watcher_thread.alive?
        time_since_last = Time.now - @pom_watcher_last_detection
        if time_since_last > 300  # Log if no activity for 5 minutes
          puts "[#{Time.now}] POM watcher thread alive, last detection #{time_since_last.to_i}s ago"
        end
      end
    rescue => e
      puts "ERROR in POM monitor thread: #{e.message}"
      puts e.backtrace.join("\n") if VERBOSE
    end
  end
end

def watch_deployments(apps_dir, notification)
  puts "Deployment watching enabled" if VERBOSE
  log_file_path = "#{apps_dir}/../logs/mule_ee.log"
  Thread.new do
    # TODO: This wont work on windows, gem 'file-tail' could be an options
    Open3.popen3("tail -F #{log_file_path}") do |stdin, stdout, stderr, thread|
      stdout.each do |line|
        if match_data = line.match(/\* Started app ['"]([^'"]+)['"]/)
          app_name = match_data[1]
          send_notification('‚úÖ', "Deployment: #{app_name} succeeded") if notification
        elsif match_data = line.match(/DeploymentException: Failed to deploy artifact \[([^\]]+)\]/)
          app_name = match_data[1]
          send_notification('‚ùå', "Deployment: #{app_name} failed") if notification
        end
      end
    end
  end
end

def run(options)
  watch_mule_and_resources_hybrid(options.apps_dir,options.projects_dir,options.ignore_formatting,options.ignore_whitespace,options.ignore_blank_lines,options.notification,options.follow_symlinks,options.symlink_interval)
  watch_pom_files(options.projects_dir,options.apps_dir,options.notification,options.pom_interval) if options.watch_pom
  watch_deployments(options.apps_dir,options.notification) if options.watch_deployments && options.notification

  puts "Mule apps directory: #{options.apps_dir}"
  puts "Monitoring for changes in: #{options.projects_dir}. Press Ctrl+C to stop."
  puts "Symlink following: #{options.follow_symlinks ? 'enabled (hybrid mode)' : 'disabled'}" if VERBOSE
  sleep
end

run(options) if __FILE__ == $PROGRAM_NAME

